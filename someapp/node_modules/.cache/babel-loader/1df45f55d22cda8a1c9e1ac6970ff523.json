{"ast":null,"code":"const radToDeg = rad => rad * 180 / Math.PI;\n\nconst rotate = v => {\n  const angle = radToDeg(Math.atan2(v[1], v[0]));\n  return rebaseAngle(angle);\n};\n\nconst matrix2dParsers = {\n  x: 4,\n  y: 5,\n  translateX: 4,\n  translateY: 5,\n  scaleX: 0,\n  scaleY: 3,\n  scale: v => (Math.abs(v[0]) + Math.abs(v[3])) / 2,\n  rotate,\n  rotateZ: rotate,\n  skewX: v => radToDeg(Math.atan(v[1])),\n  skewY: v => radToDeg(Math.atan(v[2])),\n  skew: v => (Math.abs(v[1]) + Math.abs(v[2])) / 2\n};\n\nconst rebaseAngle = angle => {\n  angle = angle % 360;\n  if (angle < 0) angle += 360;\n  return angle;\n};\n\nconst rotateZ = rotate;\n\nconst scaleX = v => Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\nconst scaleY = v => Math.sqrt(v[4] * v[4] + v[5] * v[5]);\n\nconst matrix3dParsers = {\n  x: 12,\n  y: 13,\n  z: 14,\n  translateX: 12,\n  translateY: 13,\n  translateZ: 14,\n  scaleX,\n  scaleY,\n  scale: v => (scaleX(v) + scaleY(v)) / 2,\n  rotateX: v => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),\n  rotateY: v => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),\n  rotateZ,\n  rotate: rotateZ,\n  skewX: v => radToDeg(Math.atan(v[4])),\n  skewY: v => radToDeg(Math.atan(v[1])),\n  skew: v => (Math.abs(v[1]) + Math.abs(v[4])) / 2\n};\n\nfunction defaultTransformValue(name) {\n  return name.includes(\"scale\") ? 1 : 0;\n}\n\nfunction parseValueFromTransform(transform, name) {\n  if (!transform || transform === \"none\") {\n    return defaultTransformValue(name);\n  }\n\n  const matrix3dMatch = transform.match(/^matrix3d\\(([-\\d.e\\s,]+)\\)$/u);\n  let parsers;\n  let match;\n\n  if (matrix3dMatch) {\n    parsers = matrix3dParsers;\n    match = matrix3dMatch;\n  } else {\n    const matrix2dMatch = transform.match(/^matrix\\(([-\\d.e\\s,]+)\\)$/u);\n    parsers = matrix2dParsers;\n    match = matrix2dMatch;\n  }\n\n  if (!match) {\n    return defaultTransformValue(name);\n  }\n\n  const valueParser = parsers[name];\n  const values = match[1].split(\",\").map(convertTransformToNumber);\n  return typeof valueParser === \"function\" ? valueParser(values) : values[valueParser];\n}\n\nconst readTransformValue = (instance, name) => {\n  const {\n    transform = \"none\"\n  } = getComputedStyle(instance);\n  return parseValueFromTransform(transform, name);\n};\n\nfunction convertTransformToNumber(value) {\n  return parseFloat(value.trim());\n}\n\nexport { parseValueFromTransform, readTransformValue };","map":{"version":3,"sources":["/Users/gagan/Desktop/sanjeev/someapp/node_modules/framer-motion/dist/es/render/html/utils/parse-transform.mjs"],"names":["radToDeg","rad","Math","PI","rotate","v","angle","atan2","rebaseAngle","matrix2dParsers","x","y","translateX","translateY","scaleX","scaleY","scale","abs","rotateZ","skewX","atan","skewY","skew","sqrt","matrix3dParsers","z","translateZ","rotateX","rotateY","defaultTransformValue","name","includes","parseValueFromTransform","transform","matrix3dMatch","match","parsers","matrix2dMatch","valueParser","values","split","map","convertTransformToNumber","readTransformValue","instance","getComputedStyle","value","parseFloat","trim"],"mappings":"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","sourcesContent":["const radToDeg = (rad) => (rad * 180) / Math.PI;\nconst rotate = (v) => {\n    const angle = radToDeg(Math.atan2(v[1], v[0]));\n    return rebaseAngle(angle);\n};\nconst matrix2dParsers = {\n    x: 4,\n    y: 5,\n    translateX: 4,\n    translateY: 5,\n    scaleX: 0,\n    scaleY: 3,\n    scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,\n    rotate,\n    rotateZ: rotate,\n    skewX: (v) => radToDeg(Math.atan(v[1])),\n    skewY: (v) => radToDeg(Math.atan(v[2])),\n    skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2,\n};\nconst rebaseAngle = (angle) => {\n    angle = angle % 360;\n    if (angle < 0)\n        angle += 360;\n    return angle;\n};\nconst rotateZ = rotate;\nconst scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);\nconst scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);\nconst matrix3dParsers = {\n    x: 12,\n    y: 13,\n    z: 14,\n    translateX: 12,\n    translateY: 13,\n    translateZ: 14,\n    scaleX,\n    scaleY,\n    scale: (v) => (scaleX(v) + scaleY(v)) / 2,\n    rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),\n    rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),\n    rotateZ,\n    rotate: rotateZ,\n    skewX: (v) => radToDeg(Math.atan(v[4])),\n    skewY: (v) => radToDeg(Math.atan(v[1])),\n    skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2,\n};\nfunction defaultTransformValue(name) {\n    return name.includes(\"scale\") ? 1 : 0;\n}\nfunction parseValueFromTransform(transform, name) {\n    if (!transform || transform === \"none\") {\n        return defaultTransformValue(name);\n    }\n    const matrix3dMatch = transform.match(/^matrix3d\\(([-\\d.e\\s,]+)\\)$/u);\n    let parsers;\n    let match;\n    if (matrix3dMatch) {\n        parsers = matrix3dParsers;\n        match = matrix3dMatch;\n    }\n    else {\n        const matrix2dMatch = transform.match(/^matrix\\(([-\\d.e\\s,]+)\\)$/u);\n        parsers = matrix2dParsers;\n        match = matrix2dMatch;\n    }\n    if (!match) {\n        return defaultTransformValue(name);\n    }\n    const valueParser = parsers[name];\n    const values = match[1].split(\",\").map(convertTransformToNumber);\n    return typeof valueParser === \"function\"\n        ? valueParser(values)\n        : values[valueParser];\n}\nconst readTransformValue = (instance, name) => {\n    const { transform = \"none\" } = getComputedStyle(instance);\n    return parseValueFromTransform(transform, name);\n};\nfunction convertTransformToNumber(value) {\n    return parseFloat(value.trim());\n}\n\nexport { parseValueFromTransform, readTransformValue };\n"]},"metadata":{},"sourceType":"module"}