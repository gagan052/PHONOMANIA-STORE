{"ast":null,"code":"import { isDragActive } from '../drag/state/is-active.mjs';\nimport { capturePointer } from '../utils/capture-pointer.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\n\nfunction isValidPressEvent(event) {\n  return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\n\n\nfunction press(targetOrSelector, onPressStart) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\n\n  const startPress = startEvent => {\n    const target = startEvent.currentTarget;\n    if (!target || !isValidPressEvent(startEvent) || isPressing.has(target)) return;\n    isPressing.add(target);\n    capturePointer(startEvent, \"set\");\n    const onPressEnd = onPressStart(target, startEvent);\n\n    const onPointerEnd = (endEvent, success) => {\n      target.removeEventListener(\"pointerup\", onPointerUp);\n      target.removeEventListener(\"pointercancel\", onPointerCancel);\n      capturePointer(endEvent, \"release\");\n\n      if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {\n        return;\n      }\n\n      isPressing.delete(target);\n\n      if (typeof onPressEnd === \"function\") {\n        onPressEnd(endEvent, {\n          success\n        });\n      }\n    };\n\n    const onPointerUp = upEvent => {\n      const isOutside = !upEvent.isTrusted ? false : checkOutside(upEvent, target instanceof Element ? target.getBoundingClientRect() : {\n        left: 0,\n        top: 0,\n        right: window.innerWidth,\n        bottom: window.innerHeight\n      });\n\n      if (isOutside) {\n        onPointerEnd(upEvent, false);\n      } else {\n        onPointerEnd(upEvent, !(target instanceof Element) || isNodeOrChild(target, upEvent.target));\n      }\n    };\n\n    const onPointerCancel = cancelEvent => {\n      onPointerEnd(cancelEvent, false);\n    };\n\n    target.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n    target.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n    target.addEventListener(\"lostpointercapture\", onPointerCancel, eventOptions);\n  };\n\n  targets.forEach(target => {\n    target = options.useGlobalTarget ? window : target;\n    let canAddKeyboardAccessibility = false;\n\n    if (target instanceof HTMLElement) {\n      canAddKeyboardAccessibility = true;\n\n      if (!isElementKeyboardAccessible(target) && target.getAttribute(\"tabindex\") === null) {\n        target.tabIndex = 0;\n      }\n    }\n\n    target.addEventListener(\"pointerdown\", startPress, eventOptions);\n\n    if (canAddKeyboardAccessibility) {\n      target.addEventListener(\"focus\", event => enableKeyboardPress(event, eventOptions), eventOptions);\n    }\n  });\n  return cancelEvents;\n}\n\nfunction checkOutside(event, rect) {\n  return event.clientX < rect.left || event.clientX > rect.right || event.clientY < rect.top || event.clientY > rect.bottom;\n}\n\nexport { press };","map":{"version":3,"sources":["/Users/gagan/Desktop/sanjeev/someapp/node_modules/motion-dom/dist/es/gestures/press/index.mjs"],"names":["isDragActive","capturePointer","isNodeOrChild","isPrimaryPointer","setupGesture","isElementKeyboardAccessible","enableKeyboardPress","isPressing","isValidPressEvent","event","press","targetOrSelector","onPressStart","options","targets","eventOptions","cancelEvents","startPress","startEvent","target","currentTarget","has","add","onPressEnd","onPointerEnd","endEvent","success","removeEventListener","onPointerUp","onPointerCancel","delete","upEvent","isOutside","isTrusted","checkOutside","Element","getBoundingClientRect","left","top","right","window","innerWidth","bottom","innerHeight","cancelEvent","addEventListener","forEach","useGlobalTarget","canAddKeyboardAccessibility","HTMLElement","getAttribute","tabIndex","rect","clientX","clientY"],"mappings":"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","sourcesContent":["import { isDragActive } from '../drag/state/is-active.mjs';\nimport { capturePointer } from '../utils/capture-pointer.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(targetOrSelector, onPressStart, options = {}) {\n    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);\n    const startPress = (startEvent) => {\n        const target = startEvent.currentTarget;\n        if (!target || !isValidPressEvent(startEvent) || isPressing.has(target))\n            return;\n        isPressing.add(target);\n        capturePointer(startEvent, \"set\");\n        const onPressEnd = onPressStart(target, startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            target.removeEventListener(\"pointerup\", onPointerUp);\n            target.removeEventListener(\"pointercancel\", onPointerCancel);\n            capturePointer(endEvent, \"release\");\n            if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {\n                return;\n            }\n            isPressing.delete(target);\n            if (typeof onPressEnd === \"function\") {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            const isOutside = !upEvent.isTrusted\n                ? false\n                : checkOutside(upEvent, target instanceof Element\n                    ? target.getBoundingClientRect()\n                    : {\n                        left: 0,\n                        top: 0,\n                        right: window.innerWidth,\n                        bottom: window.innerHeight,\n                    });\n            if (isOutside) {\n                onPointerEnd(upEvent, false);\n            }\n            else {\n                onPointerEnd(upEvent, !(target instanceof Element) ||\n                    isNodeOrChild(target, upEvent.target));\n            }\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        target.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n        target.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n        target.addEventListener(\"lostpointercapture\", onPointerCancel, eventOptions);\n    };\n    targets.forEach((target) => {\n        target = options.useGlobalTarget ? window : target;\n        let canAddKeyboardAccessibility = false;\n        if (target instanceof HTMLElement) {\n            canAddKeyboardAccessibility = true;\n            if (!isElementKeyboardAccessible(target) &&\n                target.getAttribute(\"tabindex\") === null) {\n                target.tabIndex = 0;\n            }\n        }\n        target.addEventListener(\"pointerdown\", startPress, eventOptions);\n        if (canAddKeyboardAccessibility) {\n            target.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\n        }\n    });\n    return cancelEvents;\n}\nfunction checkOutside(event, rect) {\n    return (event.clientX < rect.left ||\n        event.clientX > rect.right ||\n        event.clientY < rect.top ||\n        event.clientY > rect.bottom);\n}\n\nexport { press };\n"]},"metadata":{},"sourceType":"module"}