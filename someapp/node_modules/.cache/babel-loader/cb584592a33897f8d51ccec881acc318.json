{"ast":null,"code":"import { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\nimport { parseValueFromTransform } from '../../html/utils/parse-transform.mjs';\n\nconst isNumOrPxType = v => v === number || v === px;\n\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key));\n\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  return removedTransforms;\n}\n\nconst positionalValues = {\n  // Dimensions\n  width: (_ref, _ref2) => {\n    let {\n      x\n    } = _ref;\n    let {\n      paddingLeft = \"0\",\n      paddingRight = \"0\"\n    } = _ref2;\n    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n  },\n  height: (_ref3, _ref4) => {\n    let {\n      y\n    } = _ref3;\n    let {\n      paddingTop = \"0\",\n      paddingBottom = \"0\"\n    } = _ref4;\n    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n  },\n  top: (_bbox, _ref5) => {\n    let {\n      top\n    } = _ref5;\n    return parseFloat(top);\n  },\n  left: (_bbox, _ref6) => {\n    let {\n      left\n    } = _ref6;\n    return parseFloat(left);\n  },\n  bottom: (_ref7, _ref8) => {\n    let {\n      y\n    } = _ref7;\n    let {\n      top\n    } = _ref8;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: (_ref9, _ref10) => {\n    let {\n      x\n    } = _ref9;\n    let {\n      left\n    } = _ref10;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: (_bbox, _ref11) => {\n    let {\n      transform\n    } = _ref11;\n    return parseValueFromTransform(transform, \"x\");\n  },\n  y: (_bbox, _ref12) => {\n    let {\n      transform\n    } = _ref12;\n    return parseValueFromTransform(transform, \"y\");\n  }\n}; // Alias translate longform names\n\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\nexport { isNumOrPxType, positionalValues, removeNonTranslationalTransform };","map":{"version":3,"sources":["/Users/gagan/Desktop/sanjeev/someapp/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"],"names":["number","px","transformPropOrder","parseValueFromTransform","isNumOrPxType","v","transformKeys","Set","nonTranslationalTransformKeys","filter","key","has","removeNonTranslationalTransform","visualElement","removedTransforms","forEach","value","getValue","undefined","push","get","set","startsWith","positionalValues","width","x","paddingLeft","paddingRight","max","min","parseFloat","height","y","paddingTop","paddingBottom","top","_bbox","left","bottom","right","transform","translateX","translateY"],"mappings":"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","sourcesContent":["import { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\nimport { parseValueFromTransform } from '../../html/utils/parse-transform.mjs';\n\nconst isNumOrPxType = (v) => v === number || v === px;\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: (_bbox, { transform }) => parseValueFromTransform(transform, \"x\"),\n    y: (_bbox, { transform }) => parseValueFromTransform(transform, \"y\"),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n\nexport { isNumOrPxType, positionalValues, removeNonTranslationalTransform };\n"]},"metadata":{},"sourceType":"module"}