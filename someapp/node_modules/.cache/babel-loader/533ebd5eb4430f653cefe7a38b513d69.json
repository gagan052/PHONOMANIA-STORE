{"ast":null,"code":"import { animateValue } from './index.mjs';\nimport { velocityPerSecond } from '../../utils/velocity-per-second.mjs';\nimport { frameData } from '../../frameloop/data.mjs';\n\nfunction inertia(_ref) {\n  let {\n    keyframes,\n    velocity = 0,\n    min,\n    max,\n    power = 0.8,\n    timeConstant = 750,\n    bounceStiffness = 500,\n    bounceDamping = 10,\n    restDelta = 1,\n    modifyTarget,\n    driver,\n    onUpdate,\n    onComplete,\n    onStop\n  } = _ref;\n  const origin = keyframes[0];\n  let currentAnimation;\n\n  function isOutOfBounds(v) {\n    return min !== undefined && v < min || max !== undefined && v > max;\n  }\n\n  function findNearestBoundary(v) {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  }\n\n  function startAnimation(options) {\n    currentAnimation && currentAnimation.stop();\n    currentAnimation = animateValue({\n      keyframes: [0, 1],\n      velocity: 0,\n      ...options,\n      driver,\n      onUpdate: v => {\n        onUpdate && onUpdate(v);\n        options.onUpdate && options.onUpdate(v);\n      },\n      onComplete,\n      onStop\n    });\n  }\n\n  function startSpring(options) {\n    startAnimation({\n      type: \"spring\",\n      stiffness: bounceStiffness,\n      damping: bounceDamping,\n      restDelta,\n      ...options\n    });\n  }\n\n  if (isOutOfBounds(origin)) {\n    // Start the animation with spring if outside the defined boundaries\n    startSpring({\n      velocity,\n      keyframes: [origin, findNearestBoundary(origin)]\n    });\n  } else {\n    /**\n     * Or if the value is out of bounds, simulate the inertia movement\n     * with the decay animation.\n     *\n     * Pre-calculate the target so we can detect if it's out-of-bounds.\n     * If it is, we want to check per frame when to switch to a spring\n     * animation\n     */\n    let target = power * velocity + origin;\n    if (typeof modifyTarget !== \"undefined\") target = modifyTarget(target);\n    const boundary = findNearestBoundary(target);\n    const heading = boundary === min ? -1 : 1;\n    let prev;\n    let current;\n\n    const checkBoundary = v => {\n      prev = current;\n      current = v;\n      velocity = velocityPerSecond(v - prev, frameData.delta);\n\n      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n        startSpring({\n          keyframes: [v, boundary],\n          velocity\n        });\n      }\n    };\n\n    startAnimation({\n      type: \"decay\",\n      keyframes: [origin, 0],\n      velocity,\n      timeConstant,\n      power,\n      restDelta,\n      modifyTarget,\n      onUpdate: isOutOfBounds(target) ? checkBoundary : undefined\n    });\n  }\n\n  return {\n    stop: () => currentAnimation && currentAnimation.stop()\n  };\n}\n\nexport { inertia };","map":{"version":3,"sources":["/Users/gagan/Desktop/sanjeev/someapp/node_modules/framer-motion/dist/es/animation/legacy-popmotion/inertia.mjs"],"names":["animateValue","velocityPerSecond","frameData","inertia","keyframes","velocity","min","max","power","timeConstant","bounceStiffness","bounceDamping","restDelta","modifyTarget","driver","onUpdate","onComplete","onStop","origin","currentAnimation","isOutOfBounds","v","undefined","findNearestBoundary","Math","abs","startAnimation","options","stop","startSpring","type","stiffness","damping","target","boundary","heading","prev","current","checkBoundary","delta"],"mappings":"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","sourcesContent":["import { animateValue } from './index.mjs';\nimport { velocityPerSecond } from '../../utils/velocity-per-second.mjs';\nimport { frameData } from '../../frameloop/data.mjs';\n\nfunction inertia({ keyframes, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop, }) {\n    const origin = keyframes[0];\n    let currentAnimation;\n    function isOutOfBounds(v) {\n        return (min !== undefined && v < min) || (max !== undefined && v > max);\n    }\n    function findNearestBoundary(v) {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    }\n    function startAnimation(options) {\n        currentAnimation && currentAnimation.stop();\n        currentAnimation = animateValue({\n            keyframes: [0, 1],\n            velocity: 0,\n            ...options,\n            driver,\n            onUpdate: (v) => {\n                onUpdate && onUpdate(v);\n                options.onUpdate && options.onUpdate(v);\n            },\n            onComplete,\n            onStop,\n        });\n    }\n    function startSpring(options) {\n        startAnimation({\n            type: \"spring\",\n            stiffness: bounceStiffness,\n            damping: bounceDamping,\n            restDelta,\n            ...options,\n        });\n    }\n    if (isOutOfBounds(origin)) {\n        // Start the animation with spring if outside the defined boundaries\n        startSpring({\n            velocity,\n            keyframes: [origin, findNearestBoundary(origin)],\n        });\n    }\n    else {\n        /**\n         * Or if the value is out of bounds, simulate the inertia movement\n         * with the decay animation.\n         *\n         * Pre-calculate the target so we can detect if it's out-of-bounds.\n         * If it is, we want to check per frame when to switch to a spring\n         * animation\n         */\n        let target = power * velocity + origin;\n        if (typeof modifyTarget !== \"undefined\")\n            target = modifyTarget(target);\n        const boundary = findNearestBoundary(target);\n        const heading = boundary === min ? -1 : 1;\n        let prev;\n        let current;\n        const checkBoundary = (v) => {\n            prev = current;\n            current = v;\n            velocity = velocityPerSecond(v - prev, frameData.delta);\n            if ((heading === 1 && v > boundary) ||\n                (heading === -1 && v < boundary)) {\n                startSpring({ keyframes: [v, boundary], velocity });\n            }\n        };\n        startAnimation({\n            type: \"decay\",\n            keyframes: [origin, 0],\n            velocity,\n            timeConstant,\n            power,\n            restDelta,\n            modifyTarget,\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,\n        });\n    }\n    return {\n        stop: () => currentAnimation && currentAnimation.stop(),\n    };\n}\n\nexport { inertia };\n"]},"metadata":{},"sourceType":"module"}