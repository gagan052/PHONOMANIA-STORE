{"ast":null,"code":"import { frame, cancelFrame, frameData } from '../frameloop/frame.mjs';\nimport { activeAnimations } from './animation-count.mjs';\nimport { statsBuffer } from './buffer.mjs';\n\nfunction record() {\n  const {\n    value\n  } = statsBuffer;\n\n  if (value === null) {\n    cancelFrame(record);\n    return;\n  }\n\n  value.frameloop.rate.push(frameData.delta);\n  value.animations.mainThread.push(activeAnimations.mainThread);\n  value.animations.waapi.push(activeAnimations.waapi);\n  value.animations.layout.push(activeAnimations.layout);\n}\n\nfunction mean(values) {\n  return values.reduce((acc, value) => acc + value, 0) / values.length;\n}\n\nfunction summarise(values) {\n  let calcAverage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mean;\n\n  if (values.length === 0) {\n    return {\n      min: 0,\n      max: 0,\n      avg: 0\n    };\n  }\n\n  return {\n    min: Math.min(...values),\n    max: Math.max(...values),\n    avg: calcAverage(values)\n  };\n}\n\nconst msToFps = ms => Math.round(1000 / ms);\n\nfunction clearStatsBuffer() {\n  statsBuffer.value = null;\n  statsBuffer.addProjectionMetrics = null;\n}\n\nfunction reportStats() {\n  const {\n    value\n  } = statsBuffer;\n\n  if (!value) {\n    throw new Error(\"Stats are not being measured\");\n  }\n\n  clearStatsBuffer();\n  cancelFrame(record);\n  const summary = {\n    frameloop: {\n      rate: summarise(value.frameloop.rate),\n      read: summarise(value.frameloop.read),\n      resolveKeyframes: summarise(value.frameloop.resolveKeyframes),\n      update: summarise(value.frameloop.update),\n      preRender: summarise(value.frameloop.preRender),\n      render: summarise(value.frameloop.render),\n      postRender: summarise(value.frameloop.postRender)\n    },\n    animations: {\n      mainThread: summarise(value.animations.mainThread),\n      waapi: summarise(value.animations.waapi),\n      layout: summarise(value.animations.layout)\n    },\n    layoutProjection: {\n      nodes: summarise(value.layoutProjection.nodes),\n      calculatedTargetDeltas: summarise(value.layoutProjection.calculatedTargetDeltas),\n      calculatedProjections: summarise(value.layoutProjection.calculatedProjections)\n    }\n  };\n  /**\n   * Convert the rate to FPS\n   */\n\n  const {\n    rate\n  } = summary.frameloop;\n  rate.min = msToFps(rate.min);\n  rate.max = msToFps(rate.max);\n  rate.avg = msToFps(rate.avg);\n  [rate.min, rate.max] = [rate.max, rate.min];\n  return summary;\n}\n\nfunction recordStats() {\n  if (statsBuffer.value) {\n    clearStatsBuffer();\n    throw new Error(\"Stats are already being measured\");\n  }\n\n  const newStatsBuffer = statsBuffer;\n  newStatsBuffer.value = {\n    frameloop: {\n      rate: [],\n      read: [],\n      resolveKeyframes: [],\n      update: [],\n      preRender: [],\n      render: [],\n      postRender: []\n    },\n    animations: {\n      mainThread: [],\n      waapi: [],\n      layout: []\n    },\n    layoutProjection: {\n      nodes: [],\n      calculatedTargetDeltas: [],\n      calculatedProjections: []\n    }\n  };\n\n  newStatsBuffer.addProjectionMetrics = metrics => {\n    const {\n      layoutProjection\n    } = newStatsBuffer.value;\n    layoutProjection.nodes.push(metrics.nodes);\n    layoutProjection.calculatedTargetDeltas.push(metrics.calculatedTargetDeltas);\n    layoutProjection.calculatedProjections.push(metrics.calculatedProjections);\n  };\n\n  frame.postRender(record, true);\n  return reportStats;\n}\n\nexport { recordStats };","map":{"version":3,"sources":["/Users/gagan/Desktop/sanjeev/someapp/node_modules/motion-dom/dist/es/stats/index.mjs"],"names":["frame","cancelFrame","frameData","activeAnimations","statsBuffer","record","value","frameloop","rate","push","delta","animations","mainThread","waapi","layout","mean","values","reduce","acc","length","summarise","calcAverage","min","max","avg","Math","msToFps","ms","round","clearStatsBuffer","addProjectionMetrics","reportStats","Error","summary","read","resolveKeyframes","update","preRender","render","postRender","layoutProjection","nodes","calculatedTargetDeltas","calculatedProjections","recordStats","newStatsBuffer","metrics"],"mappings":"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","sourcesContent":["import { frame, cancelFrame, frameData } from '../frameloop/frame.mjs';\nimport { activeAnimations } from './animation-count.mjs';\nimport { statsBuffer } from './buffer.mjs';\n\nfunction record() {\n    const { value } = statsBuffer;\n    if (value === null) {\n        cancelFrame(record);\n        return;\n    }\n    value.frameloop.rate.push(frameData.delta);\n    value.animations.mainThread.push(activeAnimations.mainThread);\n    value.animations.waapi.push(activeAnimations.waapi);\n    value.animations.layout.push(activeAnimations.layout);\n}\nfunction mean(values) {\n    return values.reduce((acc, value) => acc + value, 0) / values.length;\n}\nfunction summarise(values, calcAverage = mean) {\n    if (values.length === 0) {\n        return {\n            min: 0,\n            max: 0,\n            avg: 0,\n        };\n    }\n    return {\n        min: Math.min(...values),\n        max: Math.max(...values),\n        avg: calcAverage(values),\n    };\n}\nconst msToFps = (ms) => Math.round(1000 / ms);\nfunction clearStatsBuffer() {\n    statsBuffer.value = null;\n    statsBuffer.addProjectionMetrics = null;\n}\nfunction reportStats() {\n    const { value } = statsBuffer;\n    if (!value) {\n        throw new Error(\"Stats are not being measured\");\n    }\n    clearStatsBuffer();\n    cancelFrame(record);\n    const summary = {\n        frameloop: {\n            rate: summarise(value.frameloop.rate),\n            read: summarise(value.frameloop.read),\n            resolveKeyframes: summarise(value.frameloop.resolveKeyframes),\n            update: summarise(value.frameloop.update),\n            preRender: summarise(value.frameloop.preRender),\n            render: summarise(value.frameloop.render),\n            postRender: summarise(value.frameloop.postRender),\n        },\n        animations: {\n            mainThread: summarise(value.animations.mainThread),\n            waapi: summarise(value.animations.waapi),\n            layout: summarise(value.animations.layout),\n        },\n        layoutProjection: {\n            nodes: summarise(value.layoutProjection.nodes),\n            calculatedTargetDeltas: summarise(value.layoutProjection.calculatedTargetDeltas),\n            calculatedProjections: summarise(value.layoutProjection.calculatedProjections),\n        },\n    };\n    /**\n     * Convert the rate to FPS\n     */\n    const { rate } = summary.frameloop;\n    rate.min = msToFps(rate.min);\n    rate.max = msToFps(rate.max);\n    rate.avg = msToFps(rate.avg);\n    [rate.min, rate.max] = [rate.max, rate.min];\n    return summary;\n}\nfunction recordStats() {\n    if (statsBuffer.value) {\n        clearStatsBuffer();\n        throw new Error(\"Stats are already being measured\");\n    }\n    const newStatsBuffer = statsBuffer;\n    newStatsBuffer.value = {\n        frameloop: {\n            rate: [],\n            read: [],\n            resolveKeyframes: [],\n            update: [],\n            preRender: [],\n            render: [],\n            postRender: [],\n        },\n        animations: {\n            mainThread: [],\n            waapi: [],\n            layout: [],\n        },\n        layoutProjection: {\n            nodes: [],\n            calculatedTargetDeltas: [],\n            calculatedProjections: [],\n        },\n    };\n    newStatsBuffer.addProjectionMetrics = (metrics) => {\n        const { layoutProjection } = newStatsBuffer.value;\n        layoutProjection.nodes.push(metrics.nodes);\n        layoutProjection.calculatedTargetDeltas.push(metrics.calculatedTargetDeltas);\n        layoutProjection.calculatedProjections.push(metrics.calculatedProjections);\n    };\n    frame.postRender(record, true);\n    return reportStats;\n}\n\nexport { recordStats };\n"]},"metadata":{},"sourceType":"module"}