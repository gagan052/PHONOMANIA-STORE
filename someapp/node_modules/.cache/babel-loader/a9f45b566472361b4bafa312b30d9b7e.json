{"ast":null,"code":"\"use client\";\n\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\nconst AnimatePresence = _ref => {\n  let {\n    children,\n    custom,\n    initial = true,\n    onExitComplete,\n    presenceAffectsLayout = true,\n    mode = \"sync\",\n    propagate = false,\n    anchorX = \"left\"\n  } = _ref;\n  const [isParentPresent, safeToRemove] = usePresence(propagate);\n  /**\n   * Filter any children that aren't ReactElements. We can only track components\n   * between renders with a props.key.\n   */\n\n  const presentChildren = useMemo(() => onlyElements(children), [children]);\n  /**\n   * Track the keys of the currently rendered children. This is used to\n   * determine which children are exiting.\n   */\n\n  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n  /**\n   * If `initial={false}` we only want to pass this to components in the first render.\n   */\n\n  const isInitialRender = useRef(true);\n  /**\n   * A ref containing the currently present children. When all exit animations\n   * are complete, we use this to re-render the component with the latest children\n   * *committed* rather than the latest children *rendered*.\n   */\n\n  const pendingPresentChildren = useRef(presentChildren);\n  /**\n   * Track which exiting children have finished animating out.\n   */\n\n  const exitComplete = useConstant(() => new Map());\n  /**\n   * Save children to render as React state. To ensure this component is concurrent-safe,\n   * we check for exiting children via an effect.\n   */\n\n  const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n  const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n  useIsomorphicLayoutEffect(() => {\n    isInitialRender.current = false;\n    pendingPresentChildren.current = presentChildren;\n    /**\n     * Update complete status of exiting children.\n     */\n\n    for (let i = 0; i < renderedChildren.length; i++) {\n      const key = getChildKey(renderedChildren[i]);\n\n      if (!presentKeys.includes(key)) {\n        if (exitComplete.get(key) !== true) {\n          exitComplete.set(key, false);\n        }\n      } else {\n        exitComplete.delete(key);\n      }\n    }\n  }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n  const exitingChildren = [];\n\n  if (presentChildren !== diffedChildren) {\n    let nextChildren = [...presentChildren];\n    /**\n     * Loop through all the currently rendered components and decide which\n     * are exiting.\n     */\n\n    for (let i = 0; i < renderedChildren.length; i++) {\n      const child = renderedChildren[i];\n      const key = getChildKey(child);\n\n      if (!presentKeys.includes(key)) {\n        nextChildren.splice(i, 0, child);\n        exitingChildren.push(child);\n      }\n    }\n    /**\n     * If we're in \"wait\" mode, and we have exiting children, we want to\n     * only render these until they've all exited.\n     */\n\n\n    if (mode === \"wait\" && exitingChildren.length) {\n      nextChildren = exitingChildren;\n    }\n\n    setRenderedChildren(onlyElements(nextChildren));\n    setDiffedChildren(presentChildren);\n    /**\n     * Early return to ensure once we've set state with the latest diffed\n     * children, we can immediately re-render.\n     */\n\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== \"production\" && mode === \"wait\" && renderedChildren.length > 1) {\n    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n  }\n  /**\n   * If we've been provided a forceRender function by the LayoutGroupContext,\n   * we can use it to force a re-render amongst all surrounding components once\n   * all components have finished animating out.\n   */\n\n\n  const {\n    forceRender\n  } = useContext(LayoutGroupContext);\n  return jsx(Fragment, {\n    children: renderedChildren.map(child => {\n      const key = getChildKey(child);\n      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);\n\n      const onExit = () => {\n        if (exitComplete.has(key)) {\n          exitComplete.set(key, true);\n        } else {\n          return;\n        }\n\n        let isEveryExitComplete = true;\n        exitComplete.forEach(isExitComplete => {\n          if (!isExitComplete) isEveryExitComplete = false;\n        });\n\n        if (isEveryExitComplete) {\n          forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n          setRenderedChildren(pendingPresentChildren.current);\n          propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());\n          onExitComplete && onExitComplete();\n        }\n      };\n\n      return jsx(PresenceChild, {\n        isPresent: isPresent,\n        initial: !isInitialRender.current || initial ? undefined : false,\n        custom: custom,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode,\n        onExitComplete: isPresent ? undefined : onExit,\n        anchorX: anchorX,\n        children: child\n      }, key);\n    })\n  });\n};\n\nexport { AnimatePresence };","map":{"version":3,"sources":["/Users/gagan/Desktop/sanjeev/someapp/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"names":["jsx","Fragment","useMemo","useRef","useState","useContext","LayoutGroupContext","useConstant","useIsomorphicLayoutEffect","PresenceChild","usePresence","onlyElements","getChildKey","AnimatePresence","children","custom","initial","onExitComplete","presenceAffectsLayout","mode","propagate","anchorX","isParentPresent","safeToRemove","presentChildren","presentKeys","map","isInitialRender","pendingPresentChildren","exitComplete","Map","diffedChildren","setDiffedChildren","renderedChildren","setRenderedChildren","current","i","length","key","includes","get","set","delete","join","exitingChildren","nextChildren","child","splice","push","process","env","NODE_ENV","console","warn","forceRender","isPresent","onExit","has","isEveryExitComplete","forEach","isExitComplete","undefined"],"mappings":"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","sourcesContent":["\"use client\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, anchorX = \"left\", }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null;\n    }\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext);\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\nexport { AnimatePresence };\n"]},"metadata":{},"sourceType":"module"}